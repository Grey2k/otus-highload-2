# Отчет о домашнем задании №4. Шардирование 
<p align="center">
<img src="static/logo.png">
</p>

## Содержание
1. [ Задание ](#task)
    - [ Цель ](#task-goal)
    - [ Приобретенные навыки ](#task-skills)
    - [ Постановка задачи ](#task-statement)
2. [ Сведения ](#information)
    - [ Используемые инструменты ](#information-tools)
    - [ Характеристики железа ](#information-computer)
3. [ Ход работы ](#work)
    - [ Предложенный вариант решения ](#work-solution)
        - ["Эффект *Lady Gaga*" с последующим решардингом](#work-solution-lady-gaga)
        - [Процедура решардинга](#work-solution-resharding)
    - [ Выполнение ](#work-execute)
4. [ Итоги ](#results)

<a name="task"></a>
## Задание
Масштабируемая подсистема диалогов.

<a name="task-goal"></a>
### Цель
Реализовать масштабируемую подсистему диалогов, применив при этом стратегию масштабирование БД, как шардирование.

<a name="task-skills"></a>
### Приобретенные навыки
В результате выполненного домашнего задания необходимо приобрести следующие навыки:
- декомпозиции предметной области;
- построения элементарной архитектуры проекта;
- применения механизма шардирования.

<a name="task-statement"></a>
### Постановка задачи
Необходимо написать систему диалогов между пользователями. Обеспечить горизонтальное масштабирование хранилищ на запись
с помощью стратегии шардирования. Предусмотреть:
- возможность процедуры решардинга;
- "эффект *Lady Gaga*" (один пользователь пишет сильно больше среднего);
- наиболее эффективную схему.

<a name="information"></a>
## Сведения
<a name="information-tools"></a>
### Используемые инструменты
Для выполнения дз понадобятся следующие инструменты: 
- [docker](https://docs.docker.com/get-docker/) (>= version 19.03.8) & [docker compose](https://docs.docker.com/compose/install/) (>= version 1.25.5);
- [python](https://www.python.org/downloads/) (>= version 3.6)
- [jq](https://stedolan.github.io/jq/download/) (>= version 1.5)

<a name="information-computer"></a>
### Характеристики железа
Домашнее задание выполнялось на железе со следующими характеристиками:
- CPU - AMD Ryzen 9: 12 ядер 24 потока;
- RAM - 2xHyperX Fury Black: DDR4 DIMM 3000MHz 8GB;
- SSD - Intel® SSD 540s Series: 480GB, 2.5in SATA 6Gb/s, 16nm, TLC

<a name="work"></a>
## Ход работы

<a name="work-solution"></a>
### Предложенный вариант решения
Для решения поставленных задач необходимо очертить им какие-то рамки, так как каждая из них может быть решена по-своему, 
исходя из требований, и представляет собой отдельную независимую проблему. Для того, чтобы не увлечься реализацией
хитрых алгоритмов балансировки и хитрых алгоритмов выбора ключа шардирования, основываясь на эффекте *Lady Gaga*, 
предлагаю правила, которые представлены ниже. Так же оговоримся, что шардировать будем таблицу **Сообщения**, 
основываясь на ID пользователя, который шлет сообщения.

<a name="work-solution-lady-gaga"></a>
#### "Эффект *Lady Gaga*" с последующим решардингом
1. Для того, чтобы знать, какой из пользователей обладает эффектом *Lady Gaga*, необходимо задать определенную метрику,
в данном случае частоту (количество отправленных пользователем сообщений в минуту), по которой мы будем определять, 
нужно ли пользователя переводить на специальный шард для самых "активных" или нет. Пусть это величина будет равна **Q**.
2. По умолчанию номер шарда будет определяться для каждого из пользователей, которые шлют сообщения, довольно просто.
От ID пользователя (в нашем случае это uuid) берется байтовое представление и переводится в целое значение. Затем 
берется остаток от деления на количество доступных шардов **N**. В зависимости от полученного остатка от деления при 
помощи правила в ProxySQL осуществляется проксирование запроса на вставку в нужный шард.
3. Но перед тем, как отдать на откуп дальнейших ройтинг запроса ProxySQL-ю, необходимо каждый раз обновлять счетчик
сообщений, которые были отосланы пользователем.
4. Если на очередной итерации обновления счетчика, мы понимаем, что пользователь обладает эффектом *Laddy Gaga*, то
записываем в кеш этого пользователя (чтоб при очередной отправке сообщений они проксировались на шард для пользователей
с эффектом *Lady Gaga*). Так же отправляем задачу воркеру для того, чтобы сообщения от этого пользователя, которые были
записаны в шард по умолчанию, были перенесены на шард для пользователей с эффектом *Lady Gaga*.

<a name="work-solution-resharding"></a>
#### Процедура решардинга
Теперь, что касается самого решардинга. Важным критерием является то, процедура решардинга должна работать без 
возникновения даунтайма. Для этого необходимо:
1. Написать отдельную программу, которая бы принимала на вход: предыдущее количество шардов **N1**, новое количество 
шардов **N2**, наименование таблицы, подвергающейся решардингу. Затем, следуя пункту 3 из предыдущего подраздела, 
произвести перераспределение строк из таблиц уже на новые шарды.
2. При этом необходимо изменить (путем создания новых правил) на стороне ProxySQL конфигурацию, в которой приведены
правила проксирования запросов. Т.е. добавить **N2-N1** правил для проксирования на шарды.

тут нужна схема алгоритма
<p align="center">
<img src="static/logo.png">
</p>

Как видно из описания выше есть определенные ограничения и недостатки данного подхода:
  - нельзя пользователя вернуть из шарда, предназначенного для **Lady Gaga**;
  - функция определения ключа шардирования очень примитивна и не может полностью равномерно распределить пользователей
  по шарадам (так как у нас ID - uuid, однако если это был бы int, то вполне сгодилась бы)
  
Подчеркну, что данный алгоритм не оптимален и не универсален в общем виде, однако для решения конкретно нашей задачи -
вполне может быть приемлем.

<a name="work-execute"></a>
### Выполнение
Для того, чтобы осуществить вышеописанную задумку нам понадобится следующее:
  - добавить новую колонку **shard_key_id** в таблицу, которую мы хотим шардировать. Данная колонка необходима для того,
  чтоб ProxySQL мог понимать, на какой из доступных ему шародов необходимо проксировать;
  - экземпляр **ProxySQL** с заданными в нем правилами проксирования;
  - экземпляр кеша(**Redis**-а) для того, чтобы персистентно отслеживать эффект *Lady Gaga'и* у пользователей;
  - шина данных **NATS** для горячей поставке уведомлений утилите, отвечающей за решардинг;
  - утилита отвечающая за решардинг;

Была добавлена миграция:
```mysql based
ALTER TABLE message
    ADD COLUMN shard_key_id INT NOT NULL AFTER chat_id;
```

Именно по ключу shard_key_id ProxySQL будет принимать решение на основе правил, в какой именно шард необходимо сделать
запись.

Поднимаем инфраструктуру, состоящую из трех экземпляров(шардов) MySQL и одного экземпляра ProxySQL
```shell script
make init
```

Для того, чтобы накатить миграции на каждый shard выполним команду:
```shell script
make migrate
```

<a name="results"></a>
## Итоги
В ходе выполнения домашнего задания был описан:
- процесс сборки и конфигурирования программного комплекса;
- алгоритм выбора ключа шардирования с учетом "эффекта Леди Гаги";
- процесс решардинга без даунтайма